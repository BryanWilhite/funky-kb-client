<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <meta name="description" content="This repo stores in static files notes taken since the 1990s. I started taking notes in Microsoft Access, then I built an ASP site over SQL server, then I built a PHP site over SQLite, then I built an Angular JS site over Azure Storage BLOBs." />
        <meta name="robots" content="index, follow" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <base href="/" />

        <link rel="canonical" href="http://the-funky-knowledge-base.github.io/" />
        <link rel="icon" type="image/x-icon" href="./images/favicon.ico" />
        <link rel="stylesheet" href="./index.min.css" />
        <script src="./index.min.js"></script>

        <title>C#: Flippant Remarks about the yield Statement - the funky knowledge base</title>
    </head>

    <body class="mdc-typography">
        <h1>the funky knowledge base</h1>
        <h2>personal notes from way, _way_ back and maybe today</h2>
        <main>
<section class="entry">
    <h3>C#: Flippant Remarks about the yield Statement</h3>

<pre>
<p>The yield statement allows us to populate an instance implementing IEnumerable. Modifying the MSDN code sample for yield, this is an example without using yield:</p>
<pre><code>public static List&amp;lt;int&amp;gt; Power(int number, int exponent)
{
    int counter = 0;
    int result = 1;
    var list = new List&amp;lt;int&amp;gt;();
    while(counter++ &amp;lt; exponent)
    {
        result = result * number;
        list.Add(result);
    }
    return list;
}
</code></pre>
<p>Without yield we are forced to choose a class implementing IEnumerable. In the example above we must use List&lt;int&gt;. Now the example using yield:</p>
<pre><code>public static IEnumerable&amp;lt;int&amp;gt; Power(int number, int exponent)
{
    int counter = 0;
    int result = 1;
    while(counter++ &amp;lt; exponent)
    {
        result = result * number;
        yield return result;
    }
}
</code></pre>
<p>The opinion here is that yield is harder to understand when the purpose of IEnumerable is not understood. One reminder is that IEnumerable requires sequential access through, say, the foreach loop. The IEnumerable interface does not define a member for random-access.</p>
<p>More information: “Using C# Yield for Readability and Performance”</p>
<pre><code>http://www.ytechie.com/2009/02/
    using-c-yield-for-readability-and-performance.html
</code></pre>

</pre>

    <span class="date"> <strong>mod date:</strong> 8/17/2009 11:09:59 PM </span>
</section>

        </main>

        <footer>
            &copy; 2019 Bryan D. Wilhite
            <a href="https://twitter.com/BryanWilhite">@BryanWilhite</a>
        </footer>
    </body>

</html>