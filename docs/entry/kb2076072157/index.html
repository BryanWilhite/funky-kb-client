<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="/style.css">
    <title>SQL Server: “An Introduction to Clustered and Non-Clustered Index Data Structures” by G. Vijayakumar - the funky knowledge base</title>
</head>
<body>
    <h1>the funky knowledge base</h1>
    <h2>personal notes from way, _way_ back and maybe today</h2>

<section class="entry">
    <h3>SQL Server: “An Introduction to Clustered and Non-Clustered Index Data Structures” by G. Vijayakumar</h3>

<pre>
<p>When you first create a new table, there is no index created by default. In technical terms, a table without an index is called a “heap”. We can confirm the fact that this new table doesn’t have an index by taking a look at the sysindexes system table, which contains one for this table with an of indid = 0. The sysindexes table, which exists in every database, tracks table and index information. “Indid” refers to Index ID, and is used to identify indexes. An indid of 0 means that a table does not have an index, and is stored by SQL Server as a heap.</p>
<p>…</p>
<p>It is really useful to have a clustered index when [we] retrieve many rows of data, ranges of data, and when BETWEEN is used in the WHERE clause. Because, the leaf level of the clustered index is the data. It should be used to save many I/Os. So, it is better to use clustered indexes to solve queries asking for ranges of data, not one row.</p>
<p>[http://www.sql-server-performance.com/articles/
per/index_data_structures_p1.aspx]</p>

</pre>

    <span class="date"> <strong>mod date:</strong> 7/31/2009 1:59:44 PM </span>
</section>


<footer>
        &copy; 2019 Bryan D. Wilhite
        <a href="https://twitter.com/BryanWilhite">@BryanWilhite</a>
</footer>
</body>
</html>