<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>XSLT Markup: Flippant Remarks for Procedural Developers Writing XSL Templates; XSLT variables - the funky knowledge base</title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>


<p>An XSL transformation is an XML document of declarations about how to rearrange the elements and attribute of another, source XML document. An XSL transformation might be seen as a &quot;type&quot; that derives from XML in the same way that any class definition ultimately extends the Object type.</p>
<p>An XSL transformation is made up of templates. Remember they are called &quot;templates&quot;; they are not functions. Templates always have a contextual relationship with the source document.</p>
<p>XSLT variables can only be assigned a value once. By chaining together declarations of variables/parameters based on values of other variables you can simulate mutability. It follows that incrementing a variable in the XSL equivalent of the for-next loop is obtained through a template 'chained' to itself (recursion). For more details about this, please see &quot;Tip: Loop with recursion in XSLT&quot; at:</p>
<pre><code>http://www-128.ibm.com/developerworks/xml/library/x-tiploop.html?ca=dnt-626
</code></pre>
<p>XSLT variables/parameters are assigned values through their &quot;select&quot; attribute. What may not be readily apparent is that the xsl:variable and xsl:param elements can contain templates and/or xsl:template content. This implies that the procedural programming design pattern of assigning a function to a variable can be achieved in XSLT like this:</p>
<pre><code>&amp;lt;xsl:variable name=&amp;quot;has_supported_property&amp;quot;&amp;gt;
    &amp;lt;xsl:choose&amp;gt;
        &amp;lt;xsl:when test=&amp;quot;w:rPr/w:b&amp;quot;&amp;gt;true&amp;lt;/xsl:when&amp;gt;
        &amp;lt;xsl:when test=&amp;quot;w:rPr/w:caps&amp;quot;&amp;gt;true&amp;lt;/xsl:when&amp;gt;
        &amp;lt;xsl:when test=&amp;quot;w:rPr/w:i&amp;quot;&amp;gt;true&amp;lt;/xsl:when&amp;gt;
        &amp;lt;xsl:when test=&amp;quot;w:rPr/w:dstrike&amp;quot;&amp;gt;true&amp;lt;/xsl:when&amp;gt;
        &amp;lt;xsl:when test=&amp;quot;w:rPr/w:smallCaps&amp;quot;&amp;gt;true&amp;lt;/xsl:when&amp;gt;
        &amp;lt;xsl:when test=&amp;quot;w:rPr/w:strike&amp;quot;&amp;gt;true&amp;lt;/xsl:when&amp;gt;
        &amp;lt;xsl:when test=&amp;quot;w:rPr/w:u&amp;quot;&amp;gt;true&amp;lt;/xsl:when&amp;gt;
        &amp;lt;xsl:otherwise&amp;gt;false&amp;lt;/xsl:otherwise&amp;gt;
    &amp;lt;/xsl:choose&amp;gt;
&amp;lt;/xsl:variable&amp;gt;
</code></pre>
<p>In procedural terms, the xsl:choose element above is part of an &quot;anonymous template&quot; that returns a value to the variable @has_supported_property. Note that contents of the xsl:when and xsl:otherwise elements are &quot;result tree fragments.&quot; The example above should include xsl:text elements to really show this. This means that XSLT variables can be assigned fragments of XML.</p>


<footer>
    &copy; 2019 the funky knowledge base
</footer>
</body>
</html>