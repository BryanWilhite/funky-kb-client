---json
{
  "documentId": "2076072237",
  "title": "“Design Patterns”; dofactory.com",
  "documentShortName": "",
  "fileName": "",
  "path": "",
  "createDate": "8/29/2009 8:58:28 PM",
  "modificationDate": "8/29/2009 8:58:28 PM",
  "templateId": "",
  "segmentId": "83",
  "isRoot": "False",
  "isActive": "True",
  "sortOrdinal": "",
  "clientId": "",
  "tag": ""
}
---

Design patterns are recurring solutions to software design problems you find again and again in real-world application development. Patterns are about design and interaction of objects, as well as providing a communication platform concerning elegant, reusable solutions to commonly encountered programming challenges.

The Gang of Four (GoF) patterns are generally considered the foundation for all other patterns. They are categorized in three groups: Creational, Structural, and Behavioral. Here you will find information on these important patterns.

To give you a head start, the C# source code is provided in 2 forms: 'structural' and 'real-world'. Structural code uses type names as defined in the pattern definition and UML diagrams. Real-world code provides real-world programming situations where you may use these patterns.

A third form, '.NET optimized' demonstrates design patterns that exploit built-in .NET 2.0, 3.0, and 3.5 features, such as, generics, attributes, delegates, object and collection initializers, automatic properties, and reflection. These and much more are available in our Design Pattern Framework 3.5TM. See our Singleton page for a .NET 3.5 Optimized code sample.

  Creational Patterns
  Abstract Factory 	  Creates an instance of several families of classes
  Builder 	  Separates object construction from its representation
  Factory Method 	  Creates an instance of several derived classes
  Prototype 	  A fully initialized instance to be copied or cloned
  Singleton 	  A class of which only a single instance can exist

  Structural Patterns
  Adapter 	  Match interfaces of different classes
  Bridge 	  Separates an object’s interface from its implementation
  Composite 	  A tree structure of simple and composite objects
  Decorator 	  Add responsibilities to objects dynamically
  Facade 	  A single class that represents an entire subsystem
  Flyweight 	  A fine-grained instance used for efficient sharing
  Proxy 	  An object representing another object

  Behavioral Patterns
  Chain of Resp. 	  A way of passing a request between a chain of objects
  Command 	  Encapsulate a command request as an object
  Interpreter 	  A way to include language elements in a program
  Iterator 	  Sequentially access the elements of a collection
  Mediator 	  Defines simplified communication between classes
  Memento 	  Capture and restore an object's internal state
  Observer 	  A way of notifying change to a number of classes
  State 	  Alter an object's behavior when its state changes
  Strategy 	  Encapsulates an algorithm inside a class
  Template Method 	  Defer the exact steps of an algorithm to a subclass
  Visitor 	  Defines a new operation to a class without change

[http://www.dofactory.com/Patterns/Patterns.aspx]
