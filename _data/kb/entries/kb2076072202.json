{
  "Document": {
    "DocumentId": 2076072202,
    "Title": "C#: Flippant Remarks about the yield Statement",
    "DocumentShortName": null,
    "FileName": null,
    "Path": null,
    "CreateDate": "2009-08-17T23:09:59",
    "ModificationDate": "2009-08-17T23:09:59",
    "TemplateId": null,
    "SegmentId": 83,
    "IsRoot": false,
    "IsActive": true,
    "SortOrdinal": null,
    "ClientId": null,
    "Tag": null
  },
  "Content": "The yield statement allows us to populate an instance implementing IEnumerable. Modifying the MSDN code sample for yield, this is an example without using yield:\n\n    public static List<int> Power(int number, int exponent)\n    {\n        int counter = 0;\n        int result = 1;\n        var list = new List<int>();\n        while(counter++ < exponent)\n        {\n            result = result * number;\n            list.Add(result);\n        }\n        return list;\n    }\n\nWithout yield we are forced to choose a class implementing IEnumerable. In the example above we must use List<int>. Now the example using yield:\n\n    public static IEnumerable<int> Power(int number, int exponent)\n    {\n        int counter = 0;\n        int result = 1;\n        while(counter++ < exponent)\n        {\n            result = result * number;\n            yield return result;\n        }\n    }\n\nThe opinion here is that yield is harder to understand when the purpose of IEnumerable is not understood. One reminder is that IEnumerable requires sequential access through, say, the foreach loop. The IEnumerable interface does not define a member for random-access.\n\nMore information: “Using C# Yield for Readability and Performance”\n\n    http://www.ytechie.com/2009/02/\n        using-c-yield-for-readability-and-performance.html\n\n",
  "Tag": "kb2076072202"
}