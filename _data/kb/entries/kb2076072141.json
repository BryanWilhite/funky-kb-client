{
  "Document": {
    "DocumentId": 2076072141,
    "Title": "“An Introduction to C# Generics”; Juval Lowy on Casting Generic Types and the Use of as and is Operators",
    "DocumentShortName": null,
    "FileName": null,
    "Path": null,
    "CreateDate": "2009-07-19T10:29:12",
    "ModificationDate": "2009-07-19T10:29:12",
    "TemplateId": null,
    "SegmentId": 83,
    "IsRoot": false,
    "IsActive": true,
    "SortOrdinal": null,
    "ClientId": null,
    "Tag": null
  },
  "Content": "The C# compiler only lets you implicitly cast generic type parameters to Object, or to constraint-specified types, as shown [below]. Such implicit casting is type safe because any incompatibility is discovered at compile-time.\n\n…Implicit casting of generic type parameters\n\ninterface ISomeInterface\n{...}\nclass BaseClass\n{...}\nclass MyClass<T> where T : BaseClass,ISomeInterface\n{\n    void SomeMethod(T t)\n    {\n        ISomeInterface obj1 = t;\n        BaseClass      obj2 = t;\n        object         obj3 = t;\n    }\n}\n\nThe compiler lets you explicitly cast generic type parameters to any other interface, but not to a class:\n\ninterface ISomeInterface\n{...}\nclass SomeClass\n{...}\nclass MyClass<T> \n{\n    void SomeMethod(T t)\n    {\n        ISomeInterface obj1 = (ISomeInterface)t;//Compiles\n        SomeClass      obj2 = (SomeClass)t;     //Does not compile\n    }\n}\n\nHowever, you can force a cast from a generic type parameter to any other type using a temporary Object variable:\n\nclass SomeClass\n{...}\n\nclass MyClass<T> \n{\n    void SomeMethod(T t)\n    {\n        object temp = t;\n        SomeClass obj = (SomeClass)temp;\n    }\n}\n\nNeedless to say, such explicit casting is dangerous because it may throw an exception at run time if the type argument used instead of the generic type parameter does not derive from the type to which you explicitly cast. Instead of risking a casting exception, a better approach is to use the is and as operators, as shown [below]. The is operator returns true if the generic type parameter is of the queried type, and as will perform a cast if the types are compatible, and will return null otherwise. You can use is and as on both generic type parameters and on generic classes with specific type arguments.\n\n…Using 'is' and 'as' operators on generic type parameters\n\npublic class MyClass<T> \n{\n    public void SomeMethod(T t)\n    {\n       if(t is int)\n       {...} \n\n       if(t is LinkedList<int,string>)\n       {...}\n\n       string str = t as string;\n       if(str != null)\n       {...}\n\n       LinkedList<int,string> list = t as LinkedList<int,string>;\n       if(list != null)\n       {...}\n    }\n}\n\n[http://msdn.microsoft.com/en-us/library/ms379564(VS.80).aspx]",
  "Tag": "kb2076072141"
}