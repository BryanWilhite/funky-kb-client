{
  "Document": {
    "DocumentId": 2076072301,
    "Title": "PHP 5.x: “How to sort an array of objects in PHP?”; stackoverflow.com",
    "DocumentShortName": null,
    "FileName": null,
    "Path": null,
    "CreateDate": "2009-10-06T17:28:27",
    "ModificationDate": "2009-10-06T17:28:27",
    "TemplateId": null,
    "SegmentId": 67,
    "IsRoot": false,
    "IsActive": true,
    "SortOrdinal": null,
    "ClientId": null,
    "Tag": null
  },
  "Content": "Here is a working code with a static method. It also uses the fact that the static method can access private ivars :) It also uses PHP awesome reflexivity <3.\n\nThe good point about that code is that Person is the class to provide the sort method, which is better on an OOP point of view. Only the class Person should be the one to know how to sort other Person. Neither People or another indepent function should.\n\nNote: not using is_callable(), as it only verifies if the parameter can be called as a function, but does not check if it's actually callable with the current visibility (public, private, protected)\n\nclass Person\n{\n    private $name, $sex, $age;\n    public function Person($name, $sex, $age)\n    {\n        $this->name = $name;\n        $this->sex = $sex;\n        $this->age = $age;\n    }\n\n    public static function sortByName(Person $p1, Person $p2)\n    {\n        return strcmp($p1->name, $p2->name);\n    }\n\n    public static function sortByAge(Person $p1, Person $p2)\n    {\n        return ($p1->age - $p2->age);\n    }\n}\n\nclass People\n{\n    private $people = array();\n    public function addPerson($name, $sex, $age)\n    {\n        $this->people[] = new Person($name, $sex, $age);\n    }\n\n    public function display()\n    {\n        print_r($this->people);\n    }\n\n    public function sort($attribute = 'name')\n    {\n        $sortFct = 'sortBy' . ucfirst(strtolower($attribute));\n        if (!in_array($sortFct, get_class_methods('Person')))\n        {\n            throw new Exception('People->sort(): Can\\'t sort by ' . $attribute);\n        }\n        usort($this->people, 'Person::' . $sortFct);\n    }\n}\n\n$people = new People;\n$people->addPerson('Steve', 'M', 31);\n$people->addPerson('John', 'M', 24);\n$people->addPerson('Jane', 'F', 26);\n$people->addPerson('Sally', 'F', 21);\n$people->display();\n$people->sort();\n$people->display();\n$people->sort('age');\n$people->display();\n\n…\n\nTake a look at usort. It allows you to specify your own comparison function. Every time two objects need to be compared, it will call that comparison function you specify to see which one is greater than the other (or if they are equal). In your comparison function you can do whatever you need to with the fields in the two Person objects to compare them.\n\nFor doing callbacks with class methods (as in your example), look at passing callbacks. For example, you could do something like this:\n\nclass People {\n    // your previously defined stuff here...\n\n    public function sort() {\n        usort($this->people, array($this, 'comparePeople'));\n    }\n\n    public function comparePeople(Person $p1, Person $p2) {\n        return strcmp($p1->getName(), $p2->getName());\n    }\n}\n\nYou would also of course need to add getName() to your Person class.\n\nFor a static approach, it might look something like this:\n\nfunction sortPeople($people) {\n    usort($people, array('People', 'comparePeople'));\n}\n\nclass People {\n    // your previously defined stuff here...\n\n    public static function comparePeople(Person $p1, Person $p2) {\n        return strcmp($p1->getName(), $p2->getName());\n    }\n}\n\nAs you can see, it looks very similar. I would not recommend you use the static approach. It's messier and violates the single responsibility principle.\n\n[http://stackoverflow.com/questions/1528561/\n    how-to-sort-an-array-of-objects-in-php]",
  "Tag": "kb2076072301"
}