{
  "Document": {
    "DocumentId": 2076072276,
    "Title": "C# Code: “Observations on the ‘if’ statement”",
    "DocumentShortName": null,
    "FileName": null,
    "Path": null,
    "CreateDate": "2009-09-26T22:25:58",
    "ModificationDate": "2009-09-26T22:25:58",
    "TemplateId": null,
    "SegmentId": 83,
    "IsRoot": false,
    "IsActive": true,
    "SortOrdinal": null,
    "ClientId": null,
    "Tag": null
  },
  "Content": "A little while back a small debate has erupted over the if statement.  There is even and anti-if campaign going on.  If you read things wrong you would think that the ‘if’ needed to be banished from all languages.   And since I had so much fun with my “Refactoring a Switch statement”  (and the rebuttal), I thought I would see what damage I could do here.  (Come on Sean Timm, I double-dog dare you)\n\nThis isn’t what is going on here – well, not as I read it.  People often make brash statements so people will reconsider their actions.  So we call things ‘evil’, compare them to the Vietnam war, say they cripple the mind, etc.\n\nWhat people are really after is the miss-use of the if statement, not the expulsion.  After all, I believe there is an if statement in virtually every computer language ever created – oh wait, assembly doesn’t have one, but do you really want to code in assembly?\n\nSo how do you miss-use something as simple as an if?   There are several ways actually.  But the basic problem is nesting (see the Arrowhead Anti-pattern for an extreme example).  Nesting code can lead to confusion — regardless of container.\n\nArrowhead Anti-pattern\n\nThe Arrowhead anti-pattern, as written up by Chris Missal is a good place to start with this one.  The code ends up looking like this (code shamelessly stolen)\n\n    if\n        if\n            if\n                if\n                    do something\n                endif\n            endif\n        endif\n    endif\n\nThe issue comes from the nested if statements.  The farther the nesting goes, the harder the code is to follow.  Flatten the list as best you can.  Another tactic is to leave the method as soon as possible (return is your friend, or throw an exception).\n\nSo the code could be refactored to look like this:\n\n    if not something\n        return;\n    if not something\n        return;\n    do something\n\nWhen I started coding (1997-ish), we thought of that having multiple return statements as bad coding practice.  Now I can’t stand to do anything else.  But there are conditions on that.  First off, if you have multiple returns in a method, return out as early as possible, or at the end.  Try not do do this in the middle.  Also, I have no problem with a method that is nothing more than a series of small if statements with returns (as the code above does).\n\nAs an aside, we are talking about code blocks here as well.  In C#, that would be any code between the { and } with a for/if/while preceding it.  I don’t like to see significant amounts of code inside of any of them.  If there is a lot of code there, move it to another method.\nNever-ending conditions Anti-Pattern\n\nYou’ve all seen this type of code.  Where the distance between the ‘if’ and the ‘then’ can be measured by counting zip codes. Below is a simple example of the problem:\n\n    if (this and that and otherthing or something and not like-like-like ...)\n\nIf your ‘if conditions’ look like something that would come out of the mouth of a valley girl, you might be a bad developer.  How often have you looked at the if conditionals had had to spend five minutes to figure out WTF what going on?  Way too often for me.\n\nAny time you add an ‘AND’ (&&) or an ‘OR’ (||) to an if statement, please think about what you are trying to do.  Or better yet, do an extract to method.  Even as simple as this refactoring would be of help:\n\n    if (INeedSmackedUpSideTheHead(data)) {\n    }\n\n    bool INeedSmackedUpSideTheHead(data) {\n        return this and that and otherthing or something and not like-like-like...);\n    }\n\nEven better would be to break up the conditions into separate calls within the new method, and remove the OR entirely.\n\n    bool IsThisBetterNow(data) {\n        if (thisThing and that and otherthing) \n        return true;\n        if (something and not like-like-like)\n        return true;\n        return false;\n    }\n\nYou may disagree with me here, but in extended conditions, OR statements are a bit unnatural.  They break up the flow and the readability.  They cause the reader to have to go back and reevaluate what has been done, because it might not be relevant anymore – because of the OR.\n\nFor-If Anti-Pattern\n\nThis is a .net 3.5 specific anti-pattern (because of linq and lambda), so if you are using a lamba-less language, just ignore this for now.  But the For-If Anit-Pattern could be considered a functional development anti-pattern, so also consider this if you are entering the wonderful world of F# or Scala. \n\nNow some will call foul on this anti-pattern, mostly because the code looks simple enough, but the solution is still nicer.  First off, there is a simple for look with a nested if:\n\n    foreach(var data in list)\n    {\n        if (data.IsTrue)\n        {\n            // do something\n        }\n    }\n\nWith lambda you can now refactor this out a bit with what is essentially a custom iterator:\n\n    foreach(var data in list.Where(x=>x.IsTrue))\n    {\n        // do something\n    }\n\nOK, that is all that comes to mind at this point.  But as you can see, I hope, there are ways to misuse something as simple as an ‘if’. Actually, it is often the simplest things that get misused the most, you rarely see an IoC library so grossly misused.  Anyway, hope you all have a good weekend.\n\n[http://elegantcode.com/2009/08/14/observations-on-the-if-statement/]",
  "Tag": "kb2076072276"
}