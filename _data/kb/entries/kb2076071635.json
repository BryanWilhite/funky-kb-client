{
  "Document": {
    "DocumentId": 2076071635,
    "Title": "Code: String Handling Functions from 1999; StringServices.bas",
    "DocumentShortName": null,
    "FileName": null,
    "Path": null,
    "CreateDate": "2005-01-20T12:44:44.757",
    "ModificationDate": "2005-01-20T12:44:44.757",
    "TemplateId": null,
    "SegmentId": 76,
    "IsRoot": false,
    "IsActive": true,
    "SortOrdinal": null,
    "ClientId": null,
    "Tag": null
  },
  "Content": "Option Explicit\n'\n' rasx 05/25/1999\n'\n\nPublic Function CountStr(ByVal Str As String, SubStr As String, _\n    Optional StartPos = 1) As Long\n\n    Dim lngCount\n    \n    If VBA.VarType(StartPos) <> vbEmpty Then _\n        If VBA.VarType(StartPos) <> vbInteger Then _\n            If VBA.VarType(StartPos) <> vbLong Then VBA.Err.Raise 450\n    \n    Do\n        lngCount = VBA.InStr(StartPos, Str, SubStr)\n        StartPos = lngCount + VBA.Len(SubStr)\n        If lngCount > 0 Then\n            CountStr = CountStr + 1\n        Else\n            Exit Do\n        End If\n    Loop\n    \nEnd Function\n\nPublic Function GetCharPos(ByVal Str As String, ByVal Chars As String, _\n    Optional ByVal Iterations = -1) As Long\n    '\n    'This function returns the char' position of the first character\n    'in Chars. If Iterations = 0 then the position of the last occurrence\n    'of Chars is returned.\n    '\n    If VBA.VarType(Iterations) <> vbInteger Then\n        If VBA.VarType(Iterations) <> vbLong Then VBA.Err.Raise 450\n    End If\n    \n    Dim lngIn As Long\n    Dim lngOut As Long\n    Dim lngLoop As Long\n    \n    lngIn = 1: lngOut = -1\n    \n    Select Case Iterations\n        Case -1\n            Do\n                lngOut = VBA.InStr(lngIn, Str, Chars)\n                If lngOut Then\n                    lngIn = lngOut + 1\n                Else\n                    Exit Do\n                End If\n            Loop\n            \n        Case Else\n            Do While lngLoop < Iterations\n                lngOut = VBA.InStr(lngIn, Str, Chars)\n                If lngOut Then\n                    lngIn = lngOut + 1\n                Else\n                    Exit Do\n                End If\n                lngLoop = lngLoop + 1\n            Loop\n            \n    End Select\n    \n    GetCharPos = lngIn - 1\n                                                        \nEnd Function\n\nPublic Function GetDigits(ByVal Str As String, _\n    Optional ByVal IncludeDecimal = False) As String\n    '\n    'This function returns only numeric characters.\n    'and, optionally, one decimal point.\n    '\n    Dim lngCount As Long\n    Dim strChar As String\n    Dim strRet As String\n    Dim strCmp As String\n\n    If IncludeDecimal Then\n        strCmp = \"1234567890.\"\n    Else\n        strCmp = \"1234567890\"\n    End If\n\n    For lngCount = 1 To Len(Str)\n        strChar = Mid$(Str, lngCount, 1)\n        If InStr(strCmp, strChar) > 0 Then\n            strRet = strRet & strChar\n        End If\n    Next\n\n    GetDigits = strRet\n  \nEnd Function\n\nPublic Function GetSubStr(ByVal Str As String, _\n    Optional ByVal StartCol = 0, _\n    Optional ByVal EndCol = 0, _\n    Optional ByVal StartChar = Empty, _\n    Optional ByVal EndChar = Empty) As String\n    'For all cases, this function returns what is between\n    'the characters and/or columns searched. This design\n    'assumes the leftmost column is column 1 so that\n    'character position equals column position.\n    \n    Dim lngLength As Long\n    \n    On Error GoTo GetSubStr_Err\n    \n    'Check Optional input.\n    If VBA.VarType(StartCol) <> vbInteger Then\n        If VBA.VarType(StartCol) <> vbLong Then VBA.Err.Raise 450\n    End If\n    If VBA.VarType(EndCol) <> vbInteger Then\n        If VBA.VarType(EndCol) <> vbLong Then VBA.Err.Raise 450\n    End If\n    If VBA.VarType(StartChar) <> vbString Then\n        If VBA.VarType(StartChar) <> vbEmpty Then VBA.Err.Raise 450\n    End If\n    If VBA.VarType(EndChar) <> vbString Then\n        If VBA.VarType(EndChar) <> vbEmpty Then VBA.Err.Raise 450\n    End If\n    \n    If StartChar = EndChar And VBA.Len(StartChar) And VBA.Len(EndChar) Then\n        VBA.MsgBox \"Error: This function cannot handle strings\" _\n            & \" with separators.\", _\n            vbCritical + vbOKOnly, \"GetSubStr Error\"\n        GoTo GetSubStr_Exit\n    End If\n    \n    If VBA.Len(StartChar) > 1 Or VBA.Len(EndChar) > 1 Then\n        VBA.MsgBox \"Error: This function cannot searches with strings\" _\n            & \" of length greater than one.\", _\n            vbCritical + vbOKOnly, \"GetSubStr Error\"\n        GoTo GetSubStr_Exit\n    End If\n    \n    'Searched on single characters only.\n    If VBA.Len(StartChar) And VBA.Len(EndChar) Then\n        lngLength = VBA.InStr(1, Str, EndChar) _\n                            - VBA.InStr(1, Str, StartChar)\n        GetSubStr = VBA.Mid$(Str, VBA.InStr(1, Str, StartChar) + 1, lngLength - 1)\n        \n    'Searched on column numbers only.\n    ElseIf StartCol >= 1 And EndCol >= 1 Then\n        lngLength = EndCol - StartCol\n        GetSubStr = VBA.Mid$(Str, StartCol, lngLength)\n        \n    'Searched on known starting column and known end character.\n    ElseIf StartCol >= 1 And VBA.Len(EndChar) Then\n        lngLength = VBA.InStr(1, Str, EndChar) - StartCol\n        GetSubStr = VBA.Mid$(Str, StartCol, lngLength)\n        \n    'Searched on known starting character and known end column.\n    ElseIf VBA.Len(StartChar) And EndCol >= 1 Then\n        lngLength = EndCol - VBA.InStr(1, Str, StartChar)\n        GetSubStr = VBA.Mid$(Str, VBA.InStr(1, Str, StartChar) + 1, lngLength - 1)\n        \n    End If\n    \nGetSubStr_Exit:\n    Exit Function\n    \nGetSubStr_Err:\n     Select Case VBA.Err\n        Case Else\n            VBA.MsgBox VBA.Err.Description, vbCritical + vbOKOnly, \"GetSubStr Error\"\n            Resume GetSubStr_Exit\n\n    End Select\n   \nEnd Function\n\nPublic Function InsNewLines(ByVal InpString As String, _\n    ByVal LineLen As Long) As String\n    \n    Dim lngPosCrLfIn As Long\n    Dim lngPosCrLfOut As Long\n    Dim lngPosSpc As Long\n    Dim strSpc As String\n    Dim strIn As String\n    Dim strOut As String\n    \n    strSpc = VBA.Space$(1)\n    strIn = InpString\n        \n    Do\n    \n            lngPosCrLfIn = GetCharPos(strIn, vbCrLf, 1)\n            lngPosSpc = GetCharPos(strIn, strSpc, 1)\n            \n            If lngPosCrLfIn <= LineLen And lngPosCrLfIn > 0 _\n               And (VBA.Len(strOut) - lngPosCrLfIn) + lngPosCrLfOut < LineLen Then\n               'Substring contains a linebreak and carriage return\n               'and its length is smaller than LineLen.\n                strOut = strOut & VBA.Mid$(strIn, 1, lngPosCrLfIn + 1)\n                strIn = VBA.Mid$(strIn, lngPosCrLfIn + 2)\n                \n            ElseIf lngPosSpc > 0 Then\n                'Split strIn at the last position of the space character.\n                strOut = strOut & VBA.Mid$(strIn, 1, lngPosSpc - 1)\n                strIn = VBA.Mid$(strIn, lngPosSpc + 1)\n                \n                'Store last position of carriage return and line feed in strOut.\n                lngPosCrLfOut = GetCharPos(strOut, vbCrLf)\n                \n                If VBA.Len(strOut) - lngPosCrLfOut >= LineLen Then\n                    'Break line.\n                    strOut = strOut & vbCrLf\n                Else\n                    'Don't break line.\n                    strOut = strOut & strSpc\n                End If\n                \n            ElseIf lngPosSpc = 0 Then\n                'In prose this must be the end of the string.\n                strOut = strOut & strIn\n                strIn = Empty\n            \n            End If\n            \n    Loop Until strIn = Empty\n        \n    InsNewLines = strOut\n    \nEnd Function\n\nPublic Function PathExists(ByVal PathName As String, _\n    Optional ByVal PathAttr = vbNormal) As Boolean\n    \n    On Error Resume Next\n    \n    If VBA.VarType(PathAttr) <> vbInteger Then _\n        If VBA.VarType(PathAttr) <> vbLong Then VBA.Err.Raise 450\n    \n    PathExists = Not (VBA.Dir(PathName, PathAttr) = Empty)\n    \nEnd Function\n\nPublic Function ReplaceChars(ByVal Str As String, ByVal OldChars As String, _\n    Optional ByVal NewChars = Empty, Optional Iterations = -1, _\n    Optional StartPos = 1, Optional ByVal UpCase = False) As String\n    '\n    'This function was conceived in the old days\n    'before the VBA.Replace() method.\n    '\n    Dim lngCounter As Long, lngLoop As Long\n    Dim lngNewPos As Long\n    \n    If VBA.VarType(NewChars) <> vbEmpty Then _\n        If VBA.VarType(NewChars) <> vbString Then VBA.Err.Raise 450\n    \n    If VBA.VarType(Iterations) <> vbEmpty Then _\n        If VBA.VarType(Iterations) <> vbInteger Then _\n            If VBA.VarType(Iterations) <> vbLong Then VBA.Err.Raise 450\n    \n    If VBA.VarType(StartPos) <> vbEmpty Then _\n        If VBA.VarType(StartPos) <> vbInteger Then _\n            If VBA.VarType(StartPos) <> vbLong Then VBA.Err.Raise 450\n    \n    If VBA.VarType(UpCase) <> vbEmpty Then _\n        If VBA.VarType(UpCase) <> vbBoolean Then VBA.Err.Raise 450\n    \n    If Iterations = -1 Then\n        'Count how many times OldChars appears.\n        Iterations = CountStr(Str, OldChars)\n    End If\n    ReplaceChars = Str\n    \n    If NewChars <> Empty Then\n        lngLoop = VBA.InStr(StartPos, Str, OldChars, vbBinaryCompare)\n        For lngCounter = 1 To Iterations\n            Str = Mid$(Str, StartPos, lngLoop - 1) & NewChars & VBA.Mid$(Str, lngLoop + VBA.Len(OldChars))\n            ReplaceChars = Str\n            lngNewPos = lngLoop + VBA.Len(NewChars)\n            lngLoop = VBA.InStr(lngNewPos, Str, OldChars, vbBinaryCompare)\n        Next\n    Else\n        If UpCase Then\n            lngLoop = VBA.InStr(StartPos, Str, OldChars, vbBinaryCompare)\n            For lngCounter = 1 To Iterations\n                Str = VBA.Mid$(Str, 1, lngLoop - 1) & VBA.UCase$(OldChars) _\n                    & VBA.Mid$(Str, lngLoop + VBA.Len(OldChars))\n                ReplaceChars = Str\n                lngNewPos = lngLoop + VBA.Len(NewChars)\n                lngLoop = VBA.InStr(lngNewPos, Str, OldChars, vbBinaryCompare)\n            Next\n        Else\n            lngLoop = VBA.InStr(1, Str, OldChars)\n            For lngCounter = 1 To Iterations\n                Str = VBA.Mid$(Str, 1, lngLoop - 1) & VBA.Mid$(Str, lngLoop + VBA.Len(OldChars))\n                ReplaceChars = Str\n                lngNewPos = lngLoop + VBA.Len(NewChars)\n                lngLoop = VBA.InStr(lngNewPos, Str, OldChars, vbBinaryCompare)\n            Next\n        End If\n    End If\n    \nEnd Function\n\nPublic Function SearchLine(ByVal Str As String, _\n    ByVal SearchStr As String) As String\n\n    'This function returns the line containing SearchStr\n    'where \"line\" implies Str contains several vbCrLf char's.\n\n    Dim lngLen As Long\n    Dim lngStart As Long\n    Dim lngEnd As Long\n    \n    lngLen = VBA.Len(Str)\n    \n    If VBA.InStr(1, Str, SearchStr) = 0 Then Exit Function\n    \n    lngStart = 1\n    lngEnd = VBA.InStr(lngStart, Str, vbCrLf)\n    Do\n        SearchLine = GetSubStr(Str, lngStart, lngEnd)\n        If VBA.InStr(1, SearchLine, SearchStr) Then Exit Do\n        lngStart = lngEnd + 2 'Recall that vbCrLf is two char's!\n        lngEnd = VBA.InStr(lngStart, Str, vbCrLf)\n    Loop\n    \nEnd Function\n\nPublic Function TitleCase(ByVal Str As String) As String\n\n    Dim lngLoop As Long\n    Dim strMid As String\n    \n    'Handle the remaining characters.\n    For lngLoop = 1 To VBA.Len(Str)\n        strMid = VBA.Mid$(Str, lngLoop, 2)\n        If strMid = \" \"\"\" Or strMid = \" '\" Then\n            'Respond to leading quotes.\n            strMid = VBA.Mid$(Str, lngLoop, 3)\n            VBA.Mid(Str, lngLoop, 3) = VBA.UCase(strMid)\n        ElseIf strMid Like \" ?\" Then\n            VBA.Mid(Str, lngLoop, 2) = VBA.UCase(strMid)\n        End If\n    Next lngLoop\n    \n    'Handle simple grammar rules.\n    'Articles:\n    Str = ReplaceChars(Str, \" The \", \" the \")\n    Str = ReplaceChars(Str, \" A \", \" a \")\n    \n    'Common Prepositions:\n    Str = ReplaceChars(Str, \" Against \", \" against \")\n    Str = ReplaceChars(Str, \" Along \", \" along \")\n    Str = ReplaceChars(Str, \" At \", \" at \")\n    Str = ReplaceChars(Str, \" Between \", \" between \")\n    Str = ReplaceChars(Str, \" By \", \" by \")\n    Str = ReplaceChars(Str, \" Down \", \" down \")\n    Str = ReplaceChars(Str, \" For \", \" for \")\n    Str = ReplaceChars(Str, \" In \", \" in \")\n    Str = ReplaceChars(Str, \" Of \", \" of \")\n    Str = ReplaceChars(Str, \" On \", \" on \")\n    Str = ReplaceChars(Str, \" Over \", \" over \")\n    Str = ReplaceChars(Str, \" To \", \" to \")\n    Str = ReplaceChars(Str, \" Up \", \" up \")\n    Str = ReplaceChars(Str, \" With \", \" with \")\n    \n    'Handle the first character.\n    strMid = VBA.Mid$(Str, 1, 1)\n    VBA.Mid(Str, 1, 1) = VBA.UCase(strMid)\n        \n    TitleCase = Str\n    \nEnd Function",
  "Tag": "kb2076071635"
}