{
  "Document": {
    "DocumentId": 2076072238,
    "Title": "C#: “Direct casting vs ‘as’ operator?”; stackoverflow.com",
    "DocumentShortName": null,
    "FileName": null,
    "Path": null,
    "CreateDate": "2009-09-07T20:16:46",
    "ModificationDate": "2009-09-07T20:16:46",
    "TemplateId": null,
    "SegmentId": 83,
    "IsRoot": false,
    "IsActive": true,
    "SortOrdinal": null,
    "ClientId": null,
    "Tag": null
  },
  "Content": "void Handler(object o, EventArgs e)\n{\n   // I swear o is a string\n   string s = (string)o; // 1\n   //-OR-\n   string s = o as string; // 2\n   // -OR-\n   string s = o.ToString(); // 3\n}\n\n/*\n\n1. Throws InvalidCastException if o is not a string. Otherwise, assigns o to s, even if o is null.\n\n2. Assigns null to s if o is not a string or if o is null. For this reason, you cannot use it with value types (the operator could never return null in that case). Otherwise, assigns o to s\n\n3. Causes a NullReferenceException of o is null. Assigns whatever o.ToString() returns to s, no matter what type o is.\n\nUse 1 for most conversions - it's simple and straightforward. I tend to almost never use 2 since if something is not the right type, I usually expect an exception to occur. I have only seen a need for this return-null type of functionality with badly designed libraries which use error codes (e.g. return null = error, instead of using exceptions).\n\n3 is not a cast and is just a method invocation. Use it for when you need the string representation of a non-string object.\n\n*/",
  "Tag": "kb2076072238"
}