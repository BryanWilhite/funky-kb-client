{
  "Document": {
    "DocumentId": 2076072218,
    "Title": "XSLT: “XPath and Default Namespace handling”",
    "DocumentShortName": null,
    "FileName": null,
    "Path": null,
    "CreateDate": "2009-08-27T10:24:25",
    "ModificationDate": "2009-08-27T10:24:25",
    "TemplateId": null,
    "SegmentId": 84,
    "IsRoot": false,
    "IsActive": true,
    "SortOrdinal": null,
    "ClientId": null,
    "Tag": null
  },
  "Content": " Now let's take the same XML however now defining all elements in the 'http://www.edankert.com/examples/' namespace.\n\nAnd instead of prefixing all the different elements (although this would cause the same problem), we're declaring a so-called default namespace at the root element.\n\nSo the XML now looks like:\n\n<catalog x­mlns=\"http://www.edankert.com/examples/\">\n  <cd>\n    <artist>Sufjan Stevens</artist>\n    <title>Illinois</title>\n    <src>http://www.sufjan.com/</src>\n  </cd>\n  <cd>\n    <artist>Stoat</artist>\n    <title>Future come and get me</title>\n    <src>http://www.stoatmusic.com/</src>\n  </cd>\n  <cd>\n    <artist>The White Stripes</artist>\n    <title>Get behind me satan</title>\n    <src>http://www.whitestripes.com/</src>\n  </cd>\n</catalog>\n\nWhen we now use the same XPath as above '//cd', we notice that nothing is returned. This is because the specified XPath returns all cd elements that have not been declared in a namespace and in the example above all the 'cd' elements are declared in the 'http://www.edankert.com/examples/' namespace.\nNamespace-Prefix mappings\n\nWe need some kind of way to specify in our XPath expression that we are looking for all 'cd' elements in the 'http://www.edankert.com/examples/' namespace.\n\nTo handle this, the XPath specification allows us to use a QName to specify an element or an attribute. A QName can be either a name on its own 'element' or a name with a prefix 'pre:element'. This prefix however needs to be mapped to a Namespace URI. So mapping the 'pre' prefix to the 'http://www.edankert.com/test' Namespace URI should allow us to find all 'element' elements defined in the 'http://www.edankert.com/test' namespace.\n\nIn this case for instance we could use the 'edx' prefix and map this prefix to the 'http://www.edankert.com/examples/' namespace URI. This would result in the following XPath expression that should return all 'cd' elements that are declared in the 'http://www.edankert.com/examples/' namespace: '//edx:cd'.\n\nAll XPath processors allow you to specify prefix-namespace mappings, however how depends on the specific implementation. See below for examples of how to map namespaces and prefixes using Jaxen (JDOM/dom4j/XOM), JAXP and XSLT.\n\n…\n\nXPath was originally designed to be used with XSLT, this (and maybe because XSLT is an XML vocabulary) might explain why declaring prefix namespace-uri mappings in XSLT seems very natural.\n\n<xsl:stylesheet version=\"1.1\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:template match=\"//edx:cd\" xmlns:edx=\"http://www.edankert.com/examples/\">\n    <xsl:apply-templates/>\n  </xsl:template>\n</xsl:stylesheet>\n\nTo specify the prefix namespace-uri we can simply specify a namespace-uri for the 'edx' prefix, using the normal XML mechanism.\n\nTo get the same output as for the previous examples, we can use a xsl:template that matches our //edx:cd XPath expression.\n\nConclusion\n\nSo, to be able to use XPath expressions on XML content defined in a (default) namespace, we need to specify a namespace prefix mapping. As we have seen, it does not matter what prefix the namespace is mapped to. \n\n[http://www.edankert.com/defaultnamespaces.html]",
  "Tag": "kb2076072218"
}